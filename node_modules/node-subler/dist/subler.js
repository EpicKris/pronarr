"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AtomTag = exports.Atoms = exports.Builder = exports.Atom = exports.Subler = exports.MediaKind = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const process_1 = require("process");
const shell_escape_1 = __importDefault(require("shell-escape"));
const lodash_1 = require("lodash");
/**
 * Represents the type of media for an input file.
 */
var MediaKind;
(function (MediaKind) {
    /** Movie */
    MediaKind["MOVIE"] = "Movie";
    /** Music */
    MediaKind["MUSIC"] = "Music";
    /** Audiobook */
    MediaKind["AUDIOBOOK"] = "Audiobook";
    /** Music Video */
    MediaKind["MUSIC_VIDEO"] = "Music Video";
    /** TV Show */
    MediaKind["TV_SHOW"] = "TV Show";
    /** Booklet */
    MediaKind["BOOKLET"] = "Booklet";
    /** Rington */
    MediaKind["RINGTONE"] = "Rightone";
})(MediaKind = exports.MediaKind || (exports.MediaKind = {}));
/** Subler */
class Subler {
    /**
     * Creates a new Subler interface with a set of Atoms that should be set to the the file at the `source`.
     * By default Media Kind is set to `MediaKind.MOVIE` and optimization level is set to true.
     * @param source Source
     * @param atoms Aroms.
     * @returns Subler
     */
    constructor(source, atoms) {
        this.subler = {
            source: source,
            chaptersPreview: true,
            optimize: true,
            organizeGroups: true,
            bitChunk64: true,
            atoms: atoms,
            mediaKind: MediaKind.MOVIE
        };
    }
    /**
     * Returns the path to the Subler executeable.
     * Assumes a homebrew installtion by default under `/usr/local/bin/SublerCli`,
     * can be overwritten setting the `SUBLER_CLI_PATH` env variable.
     */
    executable() {
        return process_1.env.SUBLER_PATH || '/usr/local/bin/SublerCli';
    }
    /**
     * Executes the tagging command as a child process, returning a handle to it.
     * @returns Child Process
     */
    spawnTag() {
        /** Command */
        const command = this.buildTagCommand();
        return child_process_1.spawn(`${command.command} ${command.args.join(' ')}`, {
            shell: true
        });
    }
    /**
     * Create the subler process command.
     * @returns Subler process command.
     */
    buildTagCommand() {
        if (!fs_1.existsSync(this.subler.source)) {
            throw new Error('Source file does not exist.');
        }
        if (this.subler.mediaKind) {
            this.subler.atoms.addAtom(new Atom('Media Kind', this.subler.mediaKind));
        }
        /** Destination */
        const dest = this.determineDest();
        if (!dest) {
            throw new Error('Destination Not Found!');
        }
        /** Atoms */
        const atoms = this.subler.atoms.args();
        /** Escaped Dest */
        const escapedSource = this.subler.source.replace(/\s/g, '\\ ');
        /** Arguments */
        const args = ['-source', escapedSource];
        /** Escaped Dest */
        const escapedDest = dest.replace(/\s/g, '\\ ');
        args.push(...['-dest', escapedDest]);
        /** Meta Tags */
        const metaTags = atoms;
        args.push(...metaTags);
        if (this.subler.chaptersPreview)
            args.push('-chapterspreview');
        if (this.subler.optimize)
            args.push('-optimize');
        if (this.subler.organizeGroups)
            args.push('-organizegroups');
        if (this.subler.bitChunk64)
            args.push('-64bitchunk');
        return {
            command: this.executable(),
            args: args
        };
    }
    /**
     * Apply the specified metadata to the source file and output it to the specified destination file.
     * @returns Spawn
     */
    tag() {
        /** Command */
        const cmd = this.buildTagCommand();
        return child_process_1.spawnSync(`${cmd.command} ${cmd.args.join(' ')}`, {
            shell: true
        });
    }
    /**
     * Sets the optimization flag.
     * @param value Value
     * @returns This
     */
    optimise(value) {
        this.subler.optimize = value;
        return this;
    }
    /**
     * Media Kind
     * @param kind Media Kind
     * @returns This
     */
    mediaKind(kind) {
        this.subler.mediaKind = kind;
        return this;
    }
    /**
     * Sets the destination of the output file.
     * @param dest Destination
     * @returns This
     */
    dest(dest) {
        this.subler.dest = dest;
        return this;
    }
    /**
     * Computes the next available path by appending.
     * @param p P
     * @param i I
     * @returns Destination
     */
    nextAvailablePath(p, i) {
        /** Path */
        const path = path_1.parse(p);
        /** Destination */
        const dest = path_1.join(path.dir, `${path.name}.${i}${path.ext}`);
        if (fs_1.existsSync(dest)) {
            this.nextAvailablePath(p, i + 1);
        }
        else {
            return dest;
        }
    }
    /**
     * Finds the next valid destination path,
     * if no dest path is supplied then the destination path is the existing file name suffixed, starting from 0.
     * @returns Destination
     */
    determineDest() {
        if (this.subler.dest) {
            if (fs_1.existsSync(this.subler.dest)) {
                return this.nextAvailablePath(this.subler.dest, 0);
            }
            else {
                return this.subler.dest;
            }
        }
        else {
            return this.nextAvailablePath(this.subler.source, 0);
        }
    }
}
exports.Subler = Subler;
/** Atom */
class Atom {
    /**
     * @param tag Tag
     * @param val Value
     */
    constructor(tag, val) {
        this.atom = {
            tag: tag,
            value: val
        };
    }
    /** Argument */
    arg() {
        /** Escaped Value */
        let escapedValue = lodash_1.trim(shell_escape_1.default([this.atom.value]).split(/\n/g).filter(value => !(value.trim() === '')).map(value => value.trim()).join(' '), '\'');
        if (this.atom.tag !== exports.AtomTag.artwork)
            escapedValue = `'${escapedValue}'`;
        return `{'${this.atom.tag}':${escapedValue}}`;
    }
}
exports.Atom = Atom;
class Builder {
    constructor() {
        /** Inner Atoms */
        this.inner = [];
    }
    /**
     * Add Atom
     * @param atom Atom
     * @returns This
     */
    addAtom(atom) {
        this.inner.push(atom);
        return this;
    }
    /**
     * Add
     * @param tag Tag
     * @param val Value
     * @returns This
     */
    add(tag, val) {
        this.inner.push(new Atom(tag, val));
        return this;
    }
    /**
     * Build
     * @returns Atoms
     */
    build() {
        return {
            inner: this.inner
        };
    }
    /**
     * Default
     * @returns Builder
     */
    static default() {
        return new Builder();
    }
}
exports.Builder = Builder;
/** Atoms */
class Atoms extends Builder {
    /**
     * All valid Metadata Atom tags.
     * @returns Metadata Tags
     */
    metadataTags() {
        /** Parameters */
        const params = [];
        for (const tag of Object.values(exports.AtomTag)) {
            params.push(tag);
        }
        return params;
    }
    /**
     * Arguments for setting the metaflag flag of subler.
     * @returns Arguments
     */
    args() {
        /** Arguments */
        const args = [];
        if (this.inner.length > 0) {
            args.push(...['-metadata', this.inner.map(atom => atom.arg()).join('')]);
        }
        return args;
    }
    /**
     * Add Atom
     * @param atom Atom
     * @returns This
     */
    addAtom(atom) {
        this.inner.push(atom);
        return this;
    }
    /**
     * Add Atoms
     * @param atoms Atoms
     * @returns This
     */
    addAtoms(atoms) {
        this.inner.push(...atoms.inner);
        return this;
    }
    /**
     * Add
     * @param tag Tag
     * @param val Value
     * @returns This
     */
    add(tag, val) {
        this.inner.push(new Atom(tag, val));
        return this;
    }
    /**
     * Atoms
     * @returns Atoms
     */
    atoms() {
        return this.inner;
    }
}
exports.Atoms = Atoms;
/** Atom Tag */
exports.AtomTag = {
    /** Artist */
    artist: 'Artist',
    /** Album Artist */
    albumArtist: 'Album Artist',
    /** Album */
    album: 'Album',
    /** Grouping */
    grouping: 'Grouping',
    /** Composer */
    composer: 'Composer',
    /** Comments */
    comments: 'Comments',
    /** Genre */
    genre: 'Genre',
    /** Release Date */
    releaseDate: 'Release Date',
    /** Track Number */
    trackNumber: 'Track #',
    /** Disk NNumber */
    diskNumber: 'Disk #',
    /** Tempo */
    tempo: 'Tempo',
    /** TV Show */
    tvShow: 'TV Show',
    /** TV Episode Number */
    tvEpisodeNumber: 'TV Episode #',
    /** TV Network */
    tvNetwork: 'TV Network',
    /** TV Episode ID */
    tvEpisodeId: 'TV Episode ID',
    /** TV Season */
    tvSeason: 'TV Season',
    /** Description */
    description: 'Description',
    /** Long Description */
    longDescription: 'Long Description',
    /** Serious Description */
    seriesDescription: 'Series Description',
    /** HD Video */
    hdVideo: 'HD Video',
    /** Rating Annotation */
    ratingAnnotation: 'Rating Annotation',
    /** Studio */
    studio: 'Studio',
    /** Cast */
    cast: 'Cast',
    /** Director */
    director: 'Director',
    /** Gapless */
    gapless: 'Gapless',
    /** Codirector */
    codirector: 'Codirector',
    /** Producers */
    producers: 'Producers',
    /** Screenwriters */
    screenwriters: 'Screenwriters',
    /** Lyrics */
    lyrics: 'Lyrics',
    /** Copyright */
    copyright: 'Copyright',
    /** Encoding Tool */
    encodingTool: 'Encoding Tool',
    /** Encoded by */
    encoded_by: 'Encoded By',
    /** Keywords */
    keywords: 'Keywords',
    /** Category */
    category: 'Category',
    /** Content ID */
    contentId: 'contentID',
    /** Artist ID */
    artistId: 'artistID',
    /** Playlist ID */
    playlistId: 'playlistID',
    /** Genre ID */
    genreId: 'genreID',
    /** Composer ID */
    composerId: 'composerID',
    /** XID */
    xid: 'XID',
    /** iTunes Account */
    itunesCccount: 'iTunes Account',
    /** iTunes Account Type */
    itunesAccountType: 'iTunes Account Type',
    /** iTunes Country */
    itunesCountry: 'iTunes Country',
    /** Track Sub-Title */
    trackSubTitle: 'Track Sub-Title',
    /** Song Description */
    songDescription: 'Song Description',
    /** Art Director */
    artDirector: 'Art Director',
    /** Arranger */
    arranger: 'Arranger',
    /** Lyricist */
    lyricist: 'Lyricist',
    /** Acknowledgement */
    acknowledgement: 'Acknowledgement',
    /** Conductor */
    conductor: 'Conductor',
    /** Linear Notes */
    linearNotes: 'Linear Notes',
    /** Record Company */
    recordCompany: 'Record Company',
    /** Original Artist */
    originalArtist: 'Original Artist',
    /** Phonogram Rights */
    phonogramRights: 'Phonogram Rights',
    /** Producer */
    producer: 'Producer',
    /** Performer */
    performer: 'Performer',
    /** Publisher */
    publisher: 'Publisher',
    /** Sound Engineer */
    soundEngineer: 'Sound Engineer',
    /** Soloist */
    soloist: 'Soloist',
    /** Credits */
    credits: 'Credits',
    /** Thanks */
    thanks: 'Thanks',
    /** Online Extras */
    onlineExtras: 'Online Extras',
    /** Executive Producer */
    executiveproducer: 'Executive Producer',
    /** Sort Name */
    sortName: 'Sort Name',
    /** Sort Artist */
    sortArtist: 'Sort Artist',
    /** Sort Album Artist */
    sortAlbumArtist: 'Sort Album Artist',
    /** Sort Album */
    sortAlbum: 'Sort Album',
    /** Sort Composer */
    sortComposer: 'Sort Composer',
    /** Sort TV Show */
    sortTvShow: 'Sort TV Show',
    /** Artwork */
    artwork: 'Artwork',
    /** Name */
    name: 'Name',
    /** Title */
    title: 'Name',
    /** Rating */
    rating: 'Rating',
    /** Media Kind */
    mediaKind: 'Media Kind'
};
for (const [ident, tag] of Object.entries(exports.AtomTag)) {
    Atoms.prototype[ident] = function (value) {
        this.inner.push(new Atom(tag, value));
        return this;
    };
    Builder.prototype[ident] = function (value) {
        this.inner.push(new Atom(tag, value));
        return this;
    };
}
//# sourceMappingURL=subler.js.map